# 목적

알고리즘 문제를 푼다. 몰랐던 것, 알았지만 체화되지 않은 것, 떠오른 생각 등을 정리한다.

## 목표

- 문제 하나를 javascript와 typescript로 각각 해결한다.
- 해결하면서 배운 것, 체화되지 않은 것, 찾아본 것 등을 정리한다.
- 해결 후, 다른 사람의 풀이를 보고 다른 점을 찾고 내것으로 만든다.

## 문제

### 13. Roman to Integer

- string 배열에서 reduce를 사용했고 누적 값의 타입은 number이다. 배열의 타입과 accumulator의 타입이 다르다. 이런 경우엔, 초기값을 명시하고 accumulator의 타입을 그에 맞춰서 지정해주면 된다. 또는 초기값만 지정해줘도 타입추론이 발생한다.

- object에 string을 키로 접근하는 것은 허용되지 않는다. 허용되는 것은 string literal로 명시하거나 string literal로 추론되는 것 뿐이다. string literal은 명시적으로 `obj["key"], type KEYS = "key1" | "key2"`처럼 나타내는 것을 의미한다. string literal로 추론되는 것은 `const key = "key"`처럼 string으로 초기화되는 상수만이 가능하다.

- enum의 항목 이름을 문자열로 변경하여 key로 사용하고 싶을 수도 있다. 이를 위해선, keyof와 typeof 연산자와 type assertion을 이용한다. `val as keyof typeof 문자열로뽑고싶은enum`처럼 사용한다.

### 20. Valid Parentheses

- object에 string을 키로 접근하는 것은 허용되지 않는다. 그래서, 직접적으로 string literal을 사용하거나, string literal로 type assertion 해야 한다. 하지만, Map 자료구조를 응용하면 비슷하게 사용 가능하다.

### 21. Merge Two Sorted Lists

- 함수의 파라미터 이름 뒤에 ?가 붙는 것은 optional parameter이다. 함수를 호출할 때 인자를 넘겨주지 않아도 된다. `function Foo(foo?: string)`와 같이 표현한다. 인자를 넘겨주지 않으면, optional parameter는 undefined가 된다. optional parameter를 풀어쓰면,
`function Foo(foo: string | undefined = undefined)`일 것이다.

### 26. Remove Duplicates from Sorted Array

- js의 array는 lexicographic을 기준으로 정렬한다. 예를 들어, 다음과 같은 `array [0, 3, 1000, 2]`가 있다면, sort를 호출한 결과값은 `[0, 1000, 2, 3]`이다. 따라서 comperator을 제공해야한다. comperator를 제공할 때는 반환한 값을 기준으로 두 원소를 정렬 한다. 결과값이 0보다 크면 두 번째 인자, 첫 번째 인자, 결과값이 0보다 작으면 첫 번째 인자, 두 번째 인자 순서이다. 동일하면 순서가 유지된다.

### 35. Search Insert Position

- indexOf함수는 원소를 찾아서 인덱스를 반환한다. 없다면 -1 반환.

### 70. Climbing Stairs

- 피보나치 시퀀스의 문제를 재귀적으로 풀었다.
- c++ vector의 reserve같이 쓰려면 `Array(10).fill(0);` Array(10)은 빈 엘리먼트 10개를 만드는 것이다. 하지만, 이터레이트를 할 수는 없다... 그래서 fill로 채워준다.

### 88. Merge Sorted Array 

- 동일한 값을 허용하는 오름차순이라는 생각에 index를 0부터 봤지만, 이 문제는 마지막 인덱스부터 보는게 맞았다...
### 100. Same Tress, 101. Symmetric Tree 

- 정렬되지 않은 트리에서 inorder traversal하면, 트리를 하나의 배열로 쭉 펴기 쉽다.
- 정렬된 트리에서 inorder traversal하면 정렬된 요소들을 차례로 나열할 수 있다.
 
### 108. Convert Sorted Array to Binary Search Tree

- tree를 만들기 위해서 재귀함수를 사용하였다. 재귀함수는 수학적귀납법과 닮아있다.
- 귀납법은 base 케이스를 증명하고, 그것을 일반화 시키는 과정이다. 첫 번째 스텝, 두 번째 스텝 ... N번째 스텝으로 이어진다.
- 재귀함수는 N번째 스텝을 만족한다고 가정하고, 첫 번째 스텝까지 내려온다. 그리고 첫 번째 스텝이 만족하면, 다시 두 번째 스텝이 만족되는 방식이다.
- 원리는 비슷한데 방향이 반대이다.
- 테크닉적으로 재귀함수는 스스로를 호출하기에 탈출조건이 필요하다.
- 탈출조건은 상당히 중요한데, 결국 첫 번째 스텝인지 확인되면 연쇄적인 탈출이 시작된다.
- 
### 110. Balanced Binary Tree

- "모든 노드의 서브트리의 depth의 차이가 1이하인 것"인지 확인해야 한다.
- 따라서 루트부터 시작하여 각 노드의 서브 트리를 확인해야 한다.
- 108번과 마찬가지로 재귀함수가 되며, 첫 번째 스텝은 leaf 노드가 null이되는 경우까지 가는 것이다.
- 그리고 다시 재귀함수가 unrolling되면서 두 번째, 세 번째 ... 마지막 N(루트노드)까지 스텝이 올라간다.
- 재밌는 점은, 한 번이라도 depth의 차이가 1초과된다면, 더 이상 볼필요 없다는 점이다.

### 111. Minimum Depth of Binary Tree

- 루트 노드에서 리프 노드까지의 거리인 minimum depth를 구한다.
- 이 문제의 재밌었던 점은 리프 노드를 정확하게 판별해야 한다는 점이다.
- 그저 서브트리를 구하듯이 하면, 리프 노드인 경우도 있고 아닌 경우도 있기에 어떤 케이스는 맞고 어떤 케이스는 틀린 답이 나온다.
- 그러므로, "left child, right child가 없는" 리프 노드를 정확히 판별하고, 리프 노드의 depth만을 유효 숫자로 봐야 했다.

### 112. Path Sum

- 111번과 원리는 같다. 눈여겨볼 점은 node의 child가 하나인 경우에 어떻게 처리할 것인가...
- 결론적으로, 하나의 path라도 정답이 존재한다면, 나머지 path가 모두 틀려도 괜찮으니, node의 child가 한 쪽 분이라면 나머지는 불가능하다고 쳐도 된다.
- child가 하나인 node까지의 path에서 정답이 존재하더라도, leaf가 아니므로 정답이 아니니까.

### 118. Pascal's Triangle

- 문제 자체는 쉽게 풀었는데, 속도가 하위 13%였다. 어떤 차이인지 확인
- 다른 풀이를 보면 push로만 호출해서 끝났는데, 내 풀이는 중간에 splice를 호출하였음. 이게 문제로 보임.
- 함수 호출에 대한 비용 + splice 내부동작의 비용인데, splice는 원소를 중간에 끼어넣기에 그 뒤에 있는 원소들이 한 칸 뒤로 미는 과정에서 발생하는 비용이 커보임
### 119. Pascal's Triangle II

- 118과 연계되는 문제. row n을 계산하려면 n - 1이 필요하고, 다시 반복... 따라서 타임 리미트를 초과하지 않으려면 계산 값을 저장해야 한다.
- 이를 위하여 2차원 배열을 썼다.
- 그런데, `new Array<Array<number>>(rowIndex + 1).fill(new Array<number>());` 이런 식으로 2차원 배열을 만들었더니, fill에 들어간 인자를 모두 참조하는 2차원 배열이 되어버린 문제가 있었다.
- 그 외에는 특별한 점은 없었던 것 같다.

### 121. Best Time to Buy and Sell Stock

- 브루트 포스로 풀었더니 타임 리미트가 발생.
- 그래서 생각해보니... buy 이후에 sell을 하니까, buy 이전의 인덱스는 다시 살펴볼 필요가 없다.
- 즉, min값을 찾아서 차이가 최대인 구간을 찾되, min이 갱신되면, 다시 처음부터 시작하여 최대 구간을 찾아서 이전과 비교하면 된다.
- 어쨌든 배열의 앞을 살펴볼 필요는 없으니까...

### 136. Single Number

- 비트연산을 사용. 같은 숫자를 xor로 연산하면 0이 나오는 특징을 이용하였다.

### 141. Linked List Cycle

- set 자료구조를 이용하여 풀었다. 속도에선 88%로 위에 있었지만, 메모리는 14.7%로 많은 공간을 사용하였다.
- 다른 사람의 풀이를 보니 포인터를 2개 들고 간다 하나의 fast 포인터로 next를 2번씩, 다른 하나는  slow 포인터로 1번씩 확인하며, fast가 slow를 따라잡으면 싸이클이 생성된 것이라 본다.

### 168. Excel Sheet Column Title

- leetcode의 discussion파트에서 10진수를 26진수로 바꾸는 것이라는 말이 와닿았다.
- 별생각없이 풀었는데...
- 그리고.. C에선 아스키코드와 숫자를 변경하는 것이, char을 이용해서 문자로 취급할지 정수로 취급할 지 결정하면 되는 것이었음.
- 하지만, js에선 이렇게 취급할 수 없었고 String.fromCharCode라는 메소드를 이용하여 해결

### 169. Majority Element

- 문제는 쉽게 풀었는데, 추가 요구 사항이 어려웠다. 시간복잡도: O(n), 공간복잡도: O(1)....
- 기존에 정렬해서 중간값을 취하는 것은 시간복잡도가 O(nlogn)이라 탈락.
- 결국 힌트를 봤는데, 무어의 투표 알고리즘이란게 있어서 이것을 사용하였음.
- 원리는... 새롭게 나타나면 +1, 다른게 나타나면 -1하여, 결국 최대한 많이 나타나는 것을 찾는 알고리즘이었음.
- 재밌네

### 190. Reverse Bits

- 문자열과 숫자를 서로 변환화는 과정이 있었다.
- 숫자를 문자열로 변환할 때 쓰는 .toString(radix), 똑같은 문자를 채울 때 쓰는 repeat, 문자열을 arry에 넣기 위해 [...문자열], 
- 마지막으로 뒤집기 위해서 배열을 뒤집고 join으로 문자열을 만들고 이것을 다시 parseInt로 숫자로 바꿔주었다.
- 하나하나 다 하려면 코드가 길어지는데 이미 함수들이 있어서 짧게 되었다.

### 191. Number of 1 Bits

- 내장된 함수들을 이용해서 풀이했음.
- number를 2진수 문자열로 바꾸기 위해, toString, 배열로 만들기 위해 split, 1을 찾기위해 filter...

### 217. Contains Duplicate

- 이제 easy 난이도는 잘 풀리는거같다
- 미디엄도 같이 풀면 괜찮을듯...

### 225. Implement Stack using Queues

- 큐 2개를 이용하여 스택을 구현하는 문제
- 큐를 2개 써서 한다는게 재밌었다.

### 5. Longest Palindromic Substring

- 가장 긴 팰린드롬 부분문자열 구하기
- 처음에 풀었을 때는 1) 부분문자열을 모두 구함 2) 부분문자열을 문자열 길이순서대로 정렬 3) 첫 번째 원소부터 팰린드롬인지 비교 하는 방법을 썼다.
- 위 방법은 해결 방법 자체는 맞았지만, 시간 초과였다.
- 왜 시간 초과였을까? 각 시간복잡도는 1) O(n^2) 2) O(nlogn) 3) O(n)이다.
- 1)이 문제였고 생각을 바꿔서... 가장 길이가 긴 부분문자열을 구하고 그것이 팰린드롬인지 확인, 다시 길이를 -1한 부분문자열을 구하고 그것이 팰린드롬인지 확인하는 방식으로 풀었다.

### 프로그래머스: 둘만의 암호

- 문제 자체는 어렵지 않았던거 같은데 문제의 함정 하나아 제대로 빠졌다.
- 알파벳을 n번째 뒤의 것과 교체하되, 건너뛰는 알파벳 목록은 포함하지 않아야 했다.
- 그래서 건너뛰느 목록과 대조를해서 알파벳을 특정하는데, 그 특정된 알파벳이 걸러여하는 알파벳 목록에 있다면 그 다음.. 그 다음... 계속 찾아야했다.
- 하지만, 난 그러지 않았지....

### 11. Container With Most Water

- 최초의 접근법은 브루트 포스. 그러나 시간 초과가 났다. 그렇다는 말은 가지치기 하듯이 안봐도 되는 경우가 많다는 것인데...
- 꽤 오래 생각했지만 혼자서는 답을 얻을 수 없어서 힌트를 봤다.
- 힌트는 매우 심플했고 답은 나왔지만, 왜 답이 나올 수 있는지 확신은 안들었다.
- 그래서, 경우의 수를 몇가지 생각해보니, 작은 쪽의 인덱스를 안쪽으로 옮겨야하는 이유를 알았다.
- 큰쪽을 안으로 옮긴다고 했을 때, 새로운 큰쪽이 이전의 큰쪽보다 크다면 옮겨도 결과는 항상같고
- 새로운 큰쪽이 이전의 큰쪽보다 작다고 했을 때, 그 넓이는 이전 큰쪽보다 넓을 수 없었다.
- 바면 작은쪽을 안으로 옮기면, 이전보다 더 커질 수 있었다.

### 15. 3Sum

- 최초의 접근 방법은 문제가 다루는 경우의 수가 nC3인 것을 발견하고
- 모든 nC3을 구하고, 셋으로 중복을 걸렀다. 그러나, 시간 초과
- 입력 값에서 중복거르기, 중간에 최대한 거르기 등 시도해 봤으나 답이 정확하지 않거나 시간초과 발생
- 답을 구하는 원리가 앞서 봤던 `11. Container With Most Water`와 비슷하다는 것을 생각하고 그렇게 접근했더니 풀렸다.

### 16. 3Sum Closest

- 11번과 15번이랑 비슷한 원리로 풀 수 있었던 문제.
- 11, 15, 16문제의 공통점은 무엇일까... 어떤 하나의 수를 정하고 그것과 일치하거나 가깝거나, 그 수를 모르지만 가장 큰 수를 선택한다.
- 선택군에 해당하는 숫자의 배열이 주어지고 이 중에서 몇개를 선택한다.
- 이 때 어떠한 조건도 붙이지 않으면 브루트 포스로 풀 수 밖에 없다. 어떤 것을 걸러야 할지 모르니까
- 하지만 정렬을 하고 나면 새로운 길이 열린다.
- 정렬되었다는 성질을 이용하면, 다음에 봐야할 숫자와 걸러도 되는 숫자를 특정지을 수 있기 때문이다.
- 오름차순 정렬이라고 하고, 목표 숫자에 가장 가까운 3개 숫자를 구한다고 했을 때, 현재 3개의 숫자의 합이 목표 보다 작다면, 3개의 숫자중에 가장 작은 숫자를 올리면 모든 경우의 수를 보게 되는 셈이다.
- 반대로 목표 숫자보다 크다면, 가장 큰 숫자의 인덱스보다 하나 작은 숫자를 선택하면 모든 경우의 수를 커버하는 셈이 된다.

### 17. Letter Combinations of a Phone Number

- 모든 경우의 수를 구해야 한다. 그룹a,b,c... 로 나누어진 문자열에서 1개씩 뽑아 모든 경우를 만드는 것이다.
- 만약 그룹의 수가 정해져있다면 for문으로 간단하게 해결할 수 있었을텐데, 그룹이 가변적이라 dfs 방식의 접근을 썼다.
- 그리고 중간에 만들어진 것을 추적하기 위하여 함수의 인자로 rest 파라미터를 썻고 함수안에선 스프레드 연산자로 받아와 사용하였다.

### 18. 4Sum
- 11, 15, 16이랑 비슷한 문제였다.

### 29. Divide Two Integers
- 실행속도가 19.35%.... 너무 낮다. 뭔가 더 괜찮은 방법이 있을 것 같네

### 31. Next Permutation
- 규칙 찾기에 실패했다. 힌트를 봤다. 이런 규칙이 있었다니...

### 33. Search in Rotated Sorted Array
### 34. Find First and Last Position of Element in Sorted Array
- 두 문제 모두 정렬된 배열 안에서 원하는 원소를 찾는 문제이다.
- 회전된 배열, 같은 원소가 있는 배열 등등 조건은 변할 수 있지만, 바이너리 서치를 쓸 수 있는 것.

### 36. Valid Sudoku
- 바로 풀이 방법을 떠올려서 풀었는데, 세세한 구현이 아쉬었다.
- 9개의 칸을 확인하기 위해, 값과 인덱스를 1:1로 대응하는 배열을 만든 것 까진 괜찮았는데 0~8 인덱스와 실제값 1~9라는 1차이를 놓쳤다...

### 45. Jump Game II
- DP 문제. DP문제는 DP라고 생각해서 풀리는 것보다, 먼저 가능한 경우를 살펴보고 메모이제이션이 가능한지 보는게 중요하다고 느낌.
- 문제랑 상관없지만, 타뷸레이션이라는 개념과 메모이제이션 개념이 구별된다. 타뷸레이션은 값을 미리 계산해두는 것. 메모이제이션은 결과가 필요할 때 답을 계산한다.

### 53. Maximum Subarray
- DP 문제는 조건을 잘 찾으면 이보다 쉬울 수 없는데, 잘못  찾거나 생각을 잘못하면 너무나 헤맨다.
- 배열이 주어지고 배열의 연속된 부분 배열에서 가장 큰 값을 찾는다. 따라서 이전 부분배열의 합과 현재 부분배열의 합을 생각했는데...
- 생각해보니 이전 부분배열의 합과 현재 부분배열이 아니라 이전 부분배열의 합과 현재 값을 비교했어야 했다.
- 현재값보다 더 작은 이전 부분 배열의 합은 버려도 무방하기 때문

### 55. Jump Game
- 속도가 하위 16%... 더 개선점이 있을까 찾아봄.
- 현재 위치로 점프해올 수 있냐는 확인하는 distance 배열을 조작하고 나서, 마지막 위치에 도착할 수 있는지 확인하는 코드르 넣으니 36%로 속도 증가.

### 63, 91 DP문제
- 91번은 처음엔 막막 했는데, 문제를 차분하게 바라보니 문자를 1글자로 볼거냐 2글자로 볼거냐로 나눌 수 있다고 생각했음.
- 1글자로 나눌까 2글자로 나눌까... 그래서 어떻게 이걸로 경우의 수를 구해볼까 생각해보니, 1글자인 경우, 2글자인 경우로 가지 치는 트리의 이미지가 떠올랐음.
- 가지의 끝은 글자를 나누다가 끝까지 간거고, 끝까지 간 경우부터 다시 더해가는 식으로 풀었음.
- 그런데, 시간 초과.... 시간초과가 시간을 줄일 수 있을까 봤더니, 비슷한 패턴은 다시 사용할 수 있을 것 같았음.
- 예를 들어 4글자가 있는데 1 1 2 로 보거나 2 2 로 나누어서 봤을 때, 뒤의 2글자는 다시 사용할 수 있으니까. 메모를 했음.

### 96. Unique Binary Search Trees
- 세 번의 시도를 했다. 첫 번째 시도는 모든 경우를 구하고 중복을 제거하려고 했다. 하지만, 중복 제거에서 문제가 발생. 트리와 서브트리 그리고 다시 서브 트리.... 끝까지 중복 체크를 해야 했기 때문
- 두 번째 시도는 힌트를 봤다. n이 증가함에따라 규칙이 생길 수 있다는 것을 알고 시작. 풀었지만 하위 6%의 런타임 시간
- 세 번째 시도는 두 번째 방법에 메모이제이션을 도입했다. 100%의 런타임을 획득. 처음임...


### 백준 1940
- 고유한 자연수들이 주어졌을때, 2개를 더해서 특정 수를 만족하는 문제.
- 고유한 자연수들을 정렬하고, 바이너리 서치를 통하여 구하겠다는 발상은 잘 한거같은데, 한 번 이라도 본 자연수를 제외하는 과정을 잘못했다. 해당 인덱스를 -1로 해버린 것인데, 이러면 정렬이 틀어져서 바이너리 서치가 제대로 동작하지 않는다.

### 백준 1629
- bigint가 중요했던 문제... bigint가 거론되는 문제는 숫자가 매우 커짐에 따라, 원하는 숫자를 어떻게 만드느냐가 중요했다.
- 하나는 문자열을 이용하여 1을 계속 붙여 매우 큰 1111111111 을 만들었고, 다른 하나는 3^6 = 3^3 * 3^3 이라는 점을 이용하여 계산했다. 곱셈법칙이라고 해야하나...
- js Number의 범위는 (2^53 -1) ~ -(2^53 - 1)이라 문제의 범위가 2^32인 보통의 4바이트 정수라면 넉넉하게 해결되고, 2^64인 8바이트 정수라면 bigint를 고려해야 한다.

### 백준 4375
- 모든 자리가 1인 숫자를 만들기 위한 방법으로 문자열을 썼다가 숫자로도 쉽게 가능해보여서 변경
- 그 결과, 1620ms -> 420ms. 아무래도 문자열을 만들고 문자열을 다시 숫자로 바꾸는 것보다 숫자만 하는게 더 빠르네.

### 백준 2178
- 2차원 배열을 생성할 때, `new Array(N).fill(0).map(_=> new Array(M).fill({value:0, visitied:false}))`;와 같은 코드를 사용했다. 첫 번째 fill에서 바로 new Array를하지 않은 것은, 그렇게하면 하나의 new Array(M)을 모두 바라보게 되기 때문이었다. 그런데... 두 번째 fill에서 `{...}`로 넘겨버리면 역시 하나의 오브젝트를 바라보게 되는 문제가 발생한다. 따라서 이 경우에도 다시 map을 써줘야 했다.
- bfs로 푸는 가중치가 같은 최단 거리 문제인데, 방문표시를 큐에서 꺼낼떄 할게아니라 집어넣을때 해야 한다. 안그러면 너무 느리다.

### 백준 2468
- 마지막 줄에 노트로 아무지역도 물에 잠기지 않을 수가 있었다 ㅜㅜ. 이걸 못 보고 넘어간 것은 문제 마지막엔 알고리즘 분류가 있어서 일부러 안본것인데 이럴수가...
- 아무튼... 이 문제는 일정 이하로 잠기는 곳으 찾는 것인데, 다른 말로 하면 일정 높이 이상을 봐도 된다는  것이랑 동일하여 그렇게 풀었다.

### 백준 4659
- 정규식을 적극적으로 사용했음.
- 모음 하나를 반드시 포함해야함, 모음이 3개 혹은 자음이3개이상 오면 안됨은 만들었음.
- 같은 글자가 연속적으로 두 번 오는것은 금지하는데 ee나oo는 허용하는것은 반복문으로 해결함.